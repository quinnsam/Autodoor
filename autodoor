#!/usr/bin/python2.7
###############################################################################
# This program automates a door for keyless unlocking                         #
# Developed by: Sam Quinn, Chauncey Yan, Ashley Greenacre, and Chris Harper.  #
# 05/13/2014                                                                  #
###############################################################################

from threading import Thread
from time import sleep
from flask import Flask, jsonify, request
from OpenSSL import SSL
import datetime
import subprocess
import serial
import os
import RPi.GPIO as GPIO
#import cqdb 
from Queue import Queue
import signal
import socket
import select
from xml.dom import minidom
import helper
import sys
import getopt
import json

###############################################################################
# Signal handler 
###############################################################################
def handler(signum, frame):
    print 'Entered Sighandler'
    print_stats()
    lock()
    sys.exit()

###############################################################################
# Usage 
###############################################################################
def usage():
    print "Autodoor [th][help]"
    print '		-t 			Test mode will not actually comunicate with the door.'
    print '		-h, --help	Print the usage message'

###############################################################################
# Setting Global varibles and environment.
###############################################################################
connected = []
lock_status = 0
night_lock = 0
arduino = serial.Serial('/dev/ttyUSB0', 9600)
queue = Queue()

# Get the config file 
#------------------------------------------------------------------------------#
try:
    with open('/home/door/Autodoor/Autodoor.json') as data_file:
        config = json.load(data_file)
except:
    print 'ERROR: Could not load config file (Autodoor.json)'
    sys.exit(1)
#------------------------------------------------------------------------------#

# Get the IPs for each user
#------------------------------------------------------------------------------#
ips= []
for i in config['users']:
    ips.append(i['ip'])
#------------------------------------------------------------------------------#
signal.signal(signal.SIGHUP, handler)
signal.signal(signal.SIGINT, handler)
signal.signal(signal.SIGQUIT, handler)
#-----------------------------------------------------------------------------#
test_mode = False
lockdown = False
#-----------------------------------------------------------------------------#
# Class object for logging and users.
class Log(object):
    def __init__(self, name=str, ip=str):
        self.mlock = 0
        self.munlock = 0
        self.mstatus = 0
        self.mcalibrate = 0
        self.mcon = 0
        self.mdcon = 0
        self.mname = name
        self.mip = ip
        self.mlockdown = 0
        self.musers = 0

    def users(self):
        self.musers += 1
    def lock(self):
        self.mlock += 1
    def unlock(self):
        self.munlock += 1
    def status(self):
        self.mstatus += 1
    def calibrate(self):
        self.mcalibrate += 1
    def conected(self):
        self.mcon += 1
    def disconected(self):
        self.mdcon += 1
    def lockdown(self):
        self.mlockdown += 1

#-----------------------------------------------------------------------------#
# Create a log dictionary
log = {'term':Log('term',0), 'glob':Log('glob', 0), 'api':Log('api',0)}

###############################################################################
# Prints the statistics from the logging function
###############################################################################
def print_stats():
    # Create a  log file for the session
    global log
    statfile = open('/home/door/logs/statistics.log', 'a')
    p = subprocess.Popen(['tmux', 'list-sessions'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()

    statfile.write("###############################**Locks/Unlocks**###############################\n%s -- %s\n" % (datetime.datetime.now(), out))
    statfile.write("Unlocks: %s\n" % log['glob'].munlock)
    statfile.write("Locks: %s\n" % log['glob'].mlock)
    statfile.write("###################################**Misc.**####################################\n")
    statfile.write("Terminal Unlocks: %s\n" % log['term'].munlock)
    statfile.write("Terminal Locks: %s\n" % log['term'].mlock)
    statfile.write("Terminal Status: %s\n" % log['term'].mstatus)
    statfile.write("Terminal Calibrates: %s\n" % log['term'].mcalibrate)
    statfile.write("Terminal Users: %s\n" % log['term'].musers)
    statfile.write("Terminal Lockdown: %s\n" % log['term'].mlockdown)
    statfile.write("###################################**Users**####################################\n")
    # Prints logging information for each user
    for user, value in log.iteritems():
        if user not in ['glob', 'term']:
            statfile.write("%s: Unlocks: %s\n" % (log[user].mname, log[user].munlock))
            statfile.write("%s: Connects: %s\n" % (log[user].mname, log[user].mcon))
            statfile.write("%s: Disconnects: %s\n" % (log[user].mname, log[user].mdcon))

    statfile.close()


###############################################################################
# Pareses and sets varibles from commandline arguments.
###############################################################################
try:
    opts, args = getopt.getopt(sys.argv[1:], "ht", ["help"])
except getopt.GetoptError as err:
    # print help information and exit:
    print str(err) # will print something like "option -a not recognized"
    usage()
    sys.exit(2)
for o, a in opts:
    if o == "-t":
        test_mode = True
    elif o in ("-h", "--help"):
        usage()
        sys.exit()
    else:
        assert False, "unhandled option"


###############################################################################
# Sends a lock request to the door to be locked
#
# Tasks:
# 1.)   Sends a singnal to the arduino to lock the door.
#
###############################################################################
def lock():
    global lock_status, log, lockdown, test_mode
    if lockdown:
        print 'Lockdown mode enabled NOT UNLOCKING'
    elif test_mode:
        print 'Fake: Sent Arduino Unlock'
    else:
        arduino.write('1')
        log['glob'].lock()

###############################################################################
# Sends a unlock request to the door to be unlocked
#
# Tasks:
# 1.)   Sends a singnal to the arduino to unlock the door.
#
###############################################################################
def unlock():
    global lock_status, log, lockdown, test_mode
    if lockdown:
        print 'Lockdown mode enabled NOT LOCKING'
    elif test_mode:
        print 'Fake: Sent Arduino Lock'
    else:
        arduino.write('0')
        log['glob'].unlock()


###############################################################################
# Returns the name of the user given their IP address.  
#
# Tasks:
# 1.)   Rececive IP address
# 2.)   Return the name associated with the IP
#
###############################################################################
def ip2name(ip):
    for i in config['users']:
        if i['ip'] == ip:
            return i['id']
    return "UNKOWN"


def api_server():
    global log
    auth = 0
    context = SSL.Context(SSL.SSLv23_METHOD)
    cer = os.path.join(os.path.dirname(__file__), 'autodoor.crt')
    key = os.path.join(os.path.dirname(__file__), 'autodoor.key')

    app = Flask(__name__)
    @app.route('/autodoor/zgpWadpooVB3FVpCWa7a/unlock/', methods=['POST'])
    def api_unlock():
        if request.headers['content-Type'] == 'application/json':
            data = request.json
            user = data['name']
            ip = data['ip']
            passwd = data['passwd']
            #print "User: %s Password: %s" % (user, passwd)
            auth = helper.auth_user(user, passwd)
            if auth == 1:
                # Unlock the door
                unlock()
                # Add user to the log dict if not already
                if ip not in log:
                    log[ip] = Log(ip2name(ip), ip)
                # Log that the user unlocked the door
                log[ip].unlock()
                # Increment API unlock.
                log['api'].unlock()
            return jsonify('{ "User" : "%s", "Action" : "unlock", "Auth" : "%s" }' % (user, auth))
        else:
            return "415 Unsupported Media Type ;)"

    sleep(12)
    lock()
    context = (cer, key)
    app.run(host='0.0.0.0', ssl_context=context)



###############################################################################
# This is a while loop that will continualy monitor for clients connecting
# and disconnecting.
#
# Tasks:
# 1.)   Setup a listening socket that the router can send messages too
# 2.)   If a device is alive and has not been added to the client list yet
#       it will unlock the door.
# 3.)   If the alive device has already been established then no action is taken.
# 4.)   After 60 seconds of the door being unlocked it will automatically lock.
#
###############################################################################
def adminserver():
    global config
    global connected
    global log
    host = ''   # Sets the host to localhost
    adminport = int(config['adminport'])
    backlog = 5
    size = 1024
    #-----------------------------------------------------------------------------#
    adminserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Prevent socket from being left in TIME_WAIT state
    adminserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    adminserver.bind((host, adminport))
    adminserver.listen(backlog)
    socket_connected = [adminserver]  # Number of connected sockets

    print 'Spawned Adminserver at Port:', adminport
    # Process that will handle all admin socket comunications.
    while True:
        readable, writeable, error = select.select(socket_connected, [], [])
        for msg in readable:
            if(msg == adminserver):   # New client connected
                new_client, address = adminserver.accept()
                hand = handshake(new_client)
                if hand != 0:
                    print 'Error with handshake:', hand
                elif hand == 0:
                    socket_connected.append(new_client)
            else:   # Existing client
                try:
                    data = msg.recv(size)
                    data = data.strip()
                    data = data.split('\n')
                    #print 'Recived:', data
                except:
                    pass
                for message in data:
                    if message != '':
                        # XML parse message
                        try:
                            xmldoc = minidom.parseString(message)
                        except:
                            msg.send('<message><type>error</type><text>Unreconized command</text></message>')
                        request = xmldoc.getElementsByTagName('type')[0].firstChild.data
                        user = xmldoc.getElementsByTagName('user')[0].firstChild.data
                        # Add user to the log dict if not already
                        if user not in log:
                            log[user] = Log(ip2name(user), user)
                        if (request == 'connected'):
                            print 'User: %s Connected at Time: %s' % (ip2name(user), datetime.datetime.now())
                            # Log user connected
                            log[user].conected()
                            # Add user to the connected list
                            if user not in connected:
                                connected.append(user)
                            # Send unlock signal to autodoor.py
                            if datetime.datetime.now().hour > 7 and datetime.datetime.now().hour < 23:
                                # Unlock the door
                                unlock()
                                # Log that the user unlocked the door
                                log[user].unlock()
                                msg.send('<message><type>ack</type><text>unlocking</text></message>')
                            else:
                                msg.send('<message><type>ack</type><text>toolate</text></message>')

                        elif (request == 'disconnected'):
                            print 'User: %s Disconnected at Time: %s' % (ip2name(user), datetime.datetime.now())
                            # Log that the user disconnected
                            log[user].disconected()
                            msg.send('<message><type>ack</type><text>disconnecting</text></message>')
                        else:
                            msg.send('<message><type>error</type><text>Unreconized command</text></message>')
                    else:   # Client left the session
                        msg.close()
                        socket_connected.remove(msg)



###############################################################################
# Monitors the seiral comunication from the Arduino
# Tasks:
# 1.)   Print what is read from the Arduino
#
###############################################################################
def arduino_watcher():
    global lock_status, lockdown
    print 'Arduino watcher has spawned'
    while True:
        read = arduino.readline()
        read = read.strip()
        print read
        if read == 'UNLOCKED':
            #print 'The door is unlocked'
            lock_status = 0
            if lockdown:
                helper.mailer('INTRUDER', 9)
        elif read == 'LOCKED':
            #print 'The door is locked'
            lock_status = 1
        elif read == 'WARN':
            #print 'The door Has been open for more than 15 Minutes'
            helper.mailer('WARN', 7)
        print '-----------------'
        read = ""

###############################################################################
# Monitors the seiral comunication from the console. 
# Tasks:
# 1.)   Read input from the daemon console screen.
# 2.)	If command is valid send command to the Arduino.
#
###############################################################################
def console_watcher():
    print 'Console monitor has spawned'
    global lockdown, log, connected
    while True:
        console = raw_input()
        console.strip()
        if console == '0':
            if lockdown:
                print 'Lockdown mode enabled NOT UNLOCKING'
            elif test_mode:
                print 'Fake: Sent Arduino: Unlock'
            else:
                arduino.write(console)
        elif console == '1':
            if lockdown:
                print 'Lockdown mode enabled NOT LOCKING'
            elif test_mode:
                print 'Fake: Sent Arduino: Lock'
            else:
                arduino.write(console)

        elif console == '2':
            if test_mode:
                print 'Fake: Sent Arduino: Status'
            else:
                arduino.write(console)
        elif console == '3':
            if lockdown:
                print 'Lockdown mode enabled NOT CALIBRATING'
            elif test_mode:
                print 'Fake: Sent Arduino: Calibrate'
            else:
                arduino.write(console)
        elif console == '4':
            #print connected
            if test_mode:
                print 'Fake: Asked for connected users'
            else:
                print '----Connected----'
                for user in connected:
                    print ip2name(user)
                log['term'].users()
        elif console == '5':
            #print Statistics
            if test_mode:
                print 'Fake: Asked for Statistics'
            else:
                print '----Statistics----'
                print_stats()
        elif console == '9':
            if test_mode:
                print 'Fake: Enabled/Disabled Lockdown Mode'
            else:
                if not lockdown:
                    print '#####*-LOCKDOWN ENABLED-*#####'
                    lockdown = True
                    log['term'].lockdown()
                    #arduino.write(console)
                else:
                    print '#####*-LOCKDOWN DISABLED-*#####'
                    lockdown = False
        else:
            print 'Error: invalid command [0-Unlock, 1-Lock, 2-Status, 3-Calibrate, 4-Connected.Clients, 5-Statistics]', console

    print "Console Monitor Exited", console

###############################################################################
# Perfomes the inital handshake between the connected socket and itself
#
# Tasks:
# 1.)   Recieve the xml message from the newly connected client
# 2.)   Send handshake back to the client
#
###############################################################################
def handshake(client):
    #print 'Entered handshake with:', client
    rv = 1
    auth = -1
    user = ''
    pin = ''
    size = 1024
    #print 'handshake: ', client.recv(size)
    try:
        raw = client.recv(size)
    except:
        print 'ERROR: Could not parse message in raw except'
        return rv

    try:
        xmldoc = minidom.parseString(raw)
    except:
        print 'ERROR: Could not parse XML'
        helper.push_notify('Could not parse XML')
        return rv

    request = xmldoc.getElementsByTagName('type')[0].firstChild.data
    user = xmldoc.getElementsByTagName('user')[0].firstChild.data
    pin = xmldoc.getElementsByTagName('pin')[0].firstChild.data
    host, port = client.getpeername()
    #print "raw: %s; request: %s; user:%s; pin:%s" % (raw,request,user,pin)
    if request == 'handshake':
        auth = helper.auth_user(user, pin)
        print "Auth = %d" % (auth)
        if auth == 1:
            client.send('<message><type>handshake</type><from>earth</from></message>')
            #print 'Connected:', client
            rv = 0
        else:
            client.send('<message><type>error</type><text>FAILED to authenticate user</text></message>')
            rv = 1
    #helper.mailer(user, rv)
    return rv

def webserver():
    # Main process that will handle all socket comunications.
    #-----------------------------------------------------------------------------#
    host = ''   # Sets the host to localhost
    webport = int(config['webport'])
    backlog = 5
    size = 1024
    #-----------------------------------------------------------------------------#
    webserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Prevent socket from being left in TIME_WAIT state
    webserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    webserver.bind((host, webport))
    webserver.listen(backlog)
    socket_connected = [webserver]  # Number of connected sockets

    print 'Webserver started on Port:', webport
    while True:
        readable, writeable, error = select.select(socket_connected, [], [])
        for web in readable:
            if(web == webserver):   # New client connected
                new_client, address = webserver.accept()
                print new_client, address, webserver, web
                hand = handshake(new_client)
                if hand != 0:
                    print 'Error with handshake:', hand
                elif hand == 0:
                    socket_connected.append(new_client)
            else:   # Existing client
                try:
                    data = web.recv(size)
                    data = data.strip()
                    data = data.split('\n')
                    #print 'Recived:', data
                except:
                    pass
                for message in data:
                    if message != '':
                        # XML parse message
                        try:
                            xmldoc = minidom.parseString(message)
                        except:
                            web.send('<message><type>error</type><text>Unreconized command</text></message>')
                        request = xmldoc.getElementsByTagName('type')[0].firstChild.data
                        user = xmldoc.getElementsByTagName('user')[0].firstChild.data
                        print 'User:', user, 'Type:', request, 'Time:', datetime.datetime.now()
                        if (request == 'status'):
                            # Call get status from autodoor.py
                            if not test_mode:
                                arduino.write('2')
                            else:
                                print 'TEST: Sent Arduino "2" (Get Status)'
                            sleep(1)
                            if lock_status == 1:
                                os.system("pb -a The door is LOCKED")
                                #web.send('<message><type>status</type><text>locked</text></message>')
                            else:
                                os.system("pb -a The door is UNLOCKED")
                                #web.send('<message><type>status</type><text>unlocked</text></message>')
                        elif (request == 'lock'):
                            # Send lock signal to autodoor.py
                            lock()
                            web.send('<message><type>ack</type><text>locking</text></message>')
                        elif (request == 'unlock'):
                            # Send unlock signal to autodoor.py
                            unlock()
                            web.send('<message><type>ack</type><text>unlocking</text></message>')
                        elif (request == 'Calibrate'):
                            # Send Calibrate signal to the arduino
                            if not (test_mode or lockdown):
                                arduino.write('3')
                            else:
                                print 'Fake: Sent Arduino "3" (Calibrate)'
                            web.send('<message><type>ack</type><text>calibrating</text></message>')
                        elif (request == 'status'):
                            # Query the status of the door
                            arduino.write('2')
                            if lock_status == 0:
                                web.send('<message><type>ack</type><text>UNLOCKED</text></message>')
                            else:
                                web.send('<message><type>ack</type><text>LOCKED</text></message>')

                        elif (request == 'Clients'):
                            # Query connected Clients
                            #web.send('<message><type>ack</type><text>' + connected + '</text></message>')
                            names = []
                            for c in connected:
                                names.append(ip2name(c))
                            os.system("pb -a Connected: %s" % names)

                        else:
                            web.send('<message><type>error</type> <text>Unreconized command</text></message>')
                    else:   # Client left the session
                        web.close()
                        socket_connected.remove(web)
                        #print 'Disconnected:', web


################################################################################
# Calibrates the Arduino board for accurate potentiometer values.
#
# Tasks:
# 1.)	Wait 10 seconds
# 2.)	Send calibrate signal to the Arudino
#
################################################################################
def calibrate():
    print 'Calibrator spawned'
    global lockdown
    #for i in range(0,2):
    sleep(10)
    if not (test_mode or lockdown):
        arduino.write('3')
    else:
        print 'Fake: Sent Arduino: 3'

    print 'Calibrator terminated'

###############################################################################
# The Main function that spawns all other theads and monitors for socket 
# connections.
# Tasks:
# 1.)   Create a PID file for the keep alive crontab.
# 2.)	Spawns a thread dedicated to pinging only one ip for each ip in the
#       ip cqdb, calibrator, Arduino monitor, and the console monitor.
# 2.)   Spawns the arduino_monitor thread to monitor serial data
# 3.)   Begins an infinte loop that will handle socket connections
#
###############################################################################
def main():
    global lock_status, log, lockdown, config

    # Create a PID file for the keep alive crontab
    pid_file = open('/home/door/Autodoor/run/autodoor.pid', 'w')
    pid = os.getpid()
    print 'PID: ', pid
    pid_file.write("%s" % pid)
    pid_file.close()

    # Calibrate the Arduino
    cali = Thread(target=calibrate)
    cali.setDaemon(True)
    cali.start()

    # Spawn adminserver
    ip_watcher = Thread(target=adminserver)
    ip_watcher.setDaemon(True)
    ip_watcher.start()
    sleep(1)

    # Spawn Arduino serial monitor
    arduino_monitor = Thread(target=arduino_watcher)
    arduino_monitor.setDaemon(True)
    arduino_monitor.start()

    # Spawn webserver
    webs = Thread(target=webserver)
    webs.setDaemon(True)
    webs.start()

    api = Thread(target=api_server)
    api.setDaemon(True)
    api.start()

    # Spawn console monitor
    #console_monitor = Thread(target=console_watcher)
    #console_monitor.setDaemon(True)
    #console_monitor.start()

    console_watcher()



if __name__ == "__main__":
    main()
