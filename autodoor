#!/usr/bin/python2.7
###############################################################################
# This program automates a door for keyless unlocking                         #
# Developed by: Sam Quinn, Chauncey Yan, Ashley Greenacre, and Chris Harper.  #
# 05/13/2014                                                                  #
###############################################################################

from threading import Thread
from time import sleep
import datetime
import subprocess
import serial
import os
import RPi.GPIO as GPIO
#import cqdb 
from Queue import Queue
import signal
import socket
import select
from xml.dom import minidom
import helper
import sys
import getopt
import json

###############################################################################
# Signal handler 
###############################################################################
def handler(signum, frame):
    print 'Entered Sighandler'
    print_stats()
    lock()
    sys.exit()

###############################################################################
# Usage 
###############################################################################
def usage():
    print "Autodoor [th][help]"
    print '		-t 			Test mode will not actually comunicate with the door.'
    print '		-h, --help	Print the usage message'

###############################################################################
# Setting Global varibles and environment.
###############################################################################
connected = []
lock_status = 0
night_lock = 0
arduino = serial.Serial('/dev/ttyUSB0', 9600)
queue = Queue()

# Get the config file 
#------------------------------------------------------------------------------#
try:
    with open('/home/door/Autodoor/Autodoor.json') as data_file:
        config = json.load(data_file)
except:
    print 'ERROR: Could not load config file (Autodoor.json)'
    sys.exit(1)
#------------------------------------------------------------------------------#

# Get the IPs for each user
#------------------------------------------------------------------------------#
ips= []
for i in config['users']:
    ips.append(i['ip'])
#------------------------------------------------------------------------------#
signal.signal(signal.SIGHUP, handler)
signal.signal(signal.SIGINT, handler)
signal.signal(signal.SIGQUIT, handler)
#-----------------------------------------------------------------------------#
host = ''   # Sets the host to localhost
port = int(config['port'])
backlog = 5
size = 1024
#-----------------------------------------------------------------------------#
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Prevent socket from being left in TIME_WAIT state
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind((host, port))
server.listen(backlog)
socket_connected = [server]  # Number of connected sockets
#-----------------------------------------------------------------------------#
test_mode = False
lockdown = False
#-----------------------------------------------------------------------------#
# Class object for logging and users.
class Log(object):
    def __init__(self, name=str, ip=str):
        self.mlock = 0
        self.munlock = 0
        self.mstatus = 0
        self.mcalibrate = 0
        self.mcon = 0
        self.mname = name
        self.mip = ip

    def lock(self):
        self.mlock += 1
    def unlock(self):
        self.munlock += 1
    def status(self):
        self.mstatus += 1
    def calibrate(self):
        self.mcalibrate += 1
    def conected(self):
        self.mcon += 1

log = [Log('term', 0), Log('glob', 0)]
#-----------------------------------------------------------------------------#

################################################################################
# Keeps track of all the Locks and Unlocks and where they originated from.
################################################################################
def logger(opt):
    global log

    if opt == '0':
        log[0].unlock()
    elif opt == '1':
        log[0].lock()
    elif opt == '2':
        log[0].status()
    elif opt == '3':
        log[0].calibrate()
    elif opt == '4':
        log[0].connected()
    else:
        return 0;

###############################################################################
# Prints the statistics from the logging function
###############################################################################
def print_stats():
    # Create a  log file for the session
    global log
    statfile = open('/home/door/logs/statistics.log', 'a')
    p = subprocess.Popen(['tmux', 'list-sessions'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()

    statfile.write("###############################**Locks/Unlocks**###############################\n%s -- %s\n" % (datetime.datetime.now(), out))
    statfile.write("Unlocks: %s\n" % log[1].munlock)
    statfile.write("Locks: %s\n" % log[1].mlock)
    statfile.write("###################################**Misc.**####################################\n")
    statfile.write("Terminal Unlocks: %s\n" % log[0].munlock)
    statfile.write("Terminal Locks: %s\n" % log[0].mlock)
    statfile.write("Terminal Status: %s\n" % log[0].mstatus)
    statfile.write("Terminal Calibrates: %s\n" % log[0].mcalibrate)
    statfile.write("Terminal Users: %s\n" % log[0].mcon)
    statfile.write("###################################**Users**####################################\n")
    # Prints logging information for each user
    for user in range(2,len(log)):
        #print "user", user
        statfile.write("%s: %s\n" % (log[user].mname, log[user].munlock))

    statfile.close()


###############################################################################
# Pareses and sets varibles from commandline arguments.
###############################################################################
try:
    opts, args = getopt.getopt(sys.argv[1:], "ht", ["help"])
except getopt.GetoptError as err:
    # print help information and exit:
    print str(err) # will print something like "option -a not recognized"
    usage()
    sys.exit(2)
for o, a in opts:
    if o == "-t":
        test_mode = True
    elif o in ("-h", "--help"):
        usage()
        sys.exit()
    else:
        assert False, "unhandled option"


###############################################################################
# Sends a lock request to the door to be locked
#
# Tasks:
# 1.)   Sends a singnal to the arduino to lock the door.
#
###############################################################################
def lock():
    global lock_status, log, lockdown, test_mode
    if not (test_mode or lockdown):
        arduino.write('1')
        log[1].lock()
        #print '+1 lock func'
    else:
        print 'Fake: Sent Arduino 1'
    #lock_status = 1

###############################################################################
# Sends a unlock request to the door to be unlocked
#
# Tasks:
# 1.)   Sends a singnal to the arduino to unlock the door.
#
###############################################################################
def unlock():
    global lock_status, log, lockdown, test_mode
    if not (test_mode or lockdown):
        arduino.write('0')
        log[1].unlock()
        #print '+1 unlock func'
    else:
        print 'Fake: Sent Arduino 0'
    #lock_status = 0

###############################################################################
# Returns the name of the user given their IP address.  
#
# Tasks:
# 1.)   Rececive IP address
# 2.)   Return the name associated with the IP
#
###############################################################################
def ip2name(ip):
    for i in config['users']:
        if i['ip'] == ip:
            return i['id']
    return "UNKOWN"

###############################################################################
# This is the main while loop that will continualy monitor for clients connecting
# and disconnecting.
#
# Tasks:
# 1.)   Ping the client to see if the device is alive or dead.
# 2.)   If a device is alive and has not been added to the client list yet
#       it will unlock the door.
# 3.)   If the alive device has already been established then no action is taken.
# 4.)   After 60 seconds of the door being unlocked it will automatically lock.
#
###############################################################################
def pinger(que):
    global connected, ips
    failed = 0
    ip_mon = que.get()
    print_log = False

    if ip_mon == '':
        return 1

    name = ip2name(ip_mon)

    # Creates a logging profile
    index = len(log)
    log.append(Log(name, ip_mon))

    # Set longer disconnect for certaint phones
    if ip_mon == '':
        failed_max = 400
    else:
        # Default disconnect timeout
        failed_max = 60

    print 'IP watcher started for: ', name
    while True:
        current_time = datetime.datetime.now()
        #print 'Time: ', current_time.hour

        # IPhone WOWLAN will help respond to pings faster and more reliable
        # https://github.com/pimatic/pimatic/issues/209
        if ip_mon == '10.0.0.50' and failed > (failed_max / 2):
            ret = subprocess.call("sudo /usr/sbin/hping3 -2 -c 2 -p 5353 %s; ping -c 2 -w 2 -n %s" % (ip_mon,ip_mon),
                    shell=True,
                    stdout=open('/dev/null', 'w'),
                    stderr=subprocess.STDOUT)
        else:
            ret = subprocess.call("ping -c 2 -w 2 -n %s" % (ip_mon),
                    shell=True,
                    stdout=open('/dev/null', 'w'),
                    stderr=subprocess.STDOUT)

        if ret == 0:
            if ip_mon in connected:
                failed = 0
                continue
            elif current_time.hour > 5 and current_time.hour < 23:
                connected.append(ip_mon)
                print name, ' Has connected:', datetime.datetime.now()
                f.open("/home/door/logs/%s" % ip_mon, "a")
                f.write("Connected[%s] - %s" % (ip_mon, datetime.datetime.now()))
                f.close()
                log[index].unlock()
                if test_mode:
                    helper.mailer(name, 2)
                unlock()
                sleep(70)
                lock()
                sleep(10)
                print_log = True
            elif current_time.hour == 0 and print_log == True:
                # Prints the stats from the logger every day
                print_stats()
                print_log = False

        else :
            if ip_mon in connected:
                f.open("/home/door/logs/%s" % ip_mon, "a")
                f.write("Failed[%s] - %s" % (ip_mon, datetime.datetime.now()))
                f.close()
                failed = failed + 1
                if failed > failed_max:
                    if test_mode:
                        helper.mailer(name, 3)
                    connected.remove(ip_mon)
                    print name, ' Disconnected:', datetime.datetime.now()

###############################################################################
# Monitors the seiral comunication from the Arduino
# Tasks:
# 1.)   Print what is read from the Arduino
#
###############################################################################
def arduino_watcher():
    global lock_status, lockdown
    print 'Arduino watcher has spawned'
    while True:
        read = arduino.readline()
        read = read.strip()
        print read
        if read == 'UNLOCKED':
            #print 'The door is unlocked'
            lock_status = 0
            if lockdown:
                helper.mailer('INTRUDER', 9)
        elif read == 'LOCKED':
            #print 'The door is locked'
            lock_status = 1
        elif read == 'WARN':
            #print 'The door Has been open for more than 15 Minutes'
            helper.mailer('WARN', 7)
        print '-----------------'
        read = ""

###############################################################################
# Monitors the seiral comunication from the console. 
# Tasks:
# 1.)   Read input from the daemon console screen.
# 2.)	If command is valid send command to the Arduino.
#
###############################################################################
def console_watcher():
    print 'Console monitor has spawned'
    global lockdown
    while True:
        console = raw_input()
        console.strip()
        if console == '0' or console == '1' or console == '2' or console == '3' or console == '9':
            if console == '9':  #Lockdown mode enabled
                if not lockdown:
                    print '#####*-LOCKDOWN ENABLED-*#####'
                    lockdown = True
                    #arduino.write(console)
                else:
                    print '#####*-LOCKDOWN DISABLED-*#####'
                    lockdown = False

            if not test_mode:
                arduino.write(console)
            else:
                print 'Fake: Sent Arduino: ', console
        elif console == '4':
            #print connected
            print '----Connected----'
            for user in connected:
                print ip2name(user)
            continue
        elif console == '5':
            #print Statistics
            print '----Statistics----'
            print_stats()
        else:
            print 'Error: invalid command [0-Unlock, 1-Lock, 2-Status, 3-Calibrate, 4-Connected.Clients, 5-Statistics]', console

        logger(console)

    print "Console Monitor Exited", console

###############################################################################
# Perfomes the inital handshake between the connected socket and itself
#
# Tasks:
# 1.)   Recieve the xml message from the newly connected client
# 2.)   Send handshake back to the client
#
###############################################################################
def handshake(client):
    #print 'Entered handshake with:', client
    rv = 1
    auth = -1
    user = ''
    pin = ''
    #print 'handshake: ', client.recv(size)
    try:
        raw = client.recv(size)
    except:
        print 'ERROR: Could not parse message in raw except'
        return rv

    try:
        xmldoc = minidom.parseString(raw)
    except:
        print 'ERROR: Could not parse XML'
        return rv

    request = xmldoc.getElementsByTagName('type')[0].firstChild.data
    user = xmldoc.getElementsByTagName('user')[0].firstChild.data
    pin = xmldoc.getElementsByTagName('pin')[0].firstChild.data
    host, port = client.getpeername()
    #print "raw: %s; request: %s; user:%s; pin:%s" % (raw,request,user,pin)
    if request == 'handshake':
        auth = helper.auth_user(user, pin)
        print "Auth = %d" % (auth)
        if auth == 1:
            client.send('<message><type>handshake</type><from>earth</from></message>')
            socket_connected.append(client)
            #print 'Connected:', client
            rv = 0
        else:
            client.send('<message><type>error</type><text>FAILED to authenticate user</text></message>')
            rv = 1
    #helper.mailer(user, rv)
    return rv

################################################################################
# Calibrates the Arduino board for accurate potentiometer values.
#
# Tasks:
# 1.)	Wait 10 seconds
# 2.)	Send calibrate signal to the Arudino
#
################################################################################
def calibrate():
    print 'Calibrator spawned'
    global lockdown
    #for i in range(0,2):
    sleep(10)
    if not (test_mode or lockdown):
        arduino.write('3')
    else:
        print 'Fake: Sent Arduino: 3'

    print 'Calibrator terminated'

###############################################################################
# The Main function that spawns all other theads and monitors for socket 
# connections.
# Tasks:
# 1.)   Create a PID file for the keep alive crontab.
# 2.)	Spawns a thread dedicated to pinging only one ip for each ip in the
#       ip cqdb, calibrator, Arduino monitor, and the console monitor.
# 2.)   Spawns the arduino_monitor thread to monitor serial data
# 3.)   Begins an infinte loop that will handle socket connections
#
###############################################################################
def main():
    global lock_status, log, lockdown

    # Create a PID file for the keep alive crontab
    pid_file = open('/home/door/Autodoor/run/autodoor.pid', 'w')
    pid = os.getpid()
    print 'PID: ', pid
    pid_file.write("%s" % pid)
    pid_file.close()

    # Calibrate the Arduino
    cali = Thread(target=calibrate)
    cali.setDaemon(True)
    cali.start()

    # Spawn a dedicated thread for each IP in the database.
    for ip in ips:
        if ip != '':
            connected.append("%s" % ip)
            queue.put(ip)
            print 'IP:', ip
            ip_watcher = Thread(target=pinger, args=(queue,))
            ip_watcher.setDaemon(True)
            ip_watcher.start()
            sleep(1)

    # Spawn Arduino serial monitor
    arduino_monitor = Thread(target=arduino_watcher)
    arduino_monitor.setDaemon(True)
    arduino_monitor.start()

    # Spawn console monitor
    console_monitor = Thread(target=console_watcher)
    console_monitor.setDaemon(True)
    console_monitor.start()

    # Main process that will handle all socket comunications.
    while True:
        readable, writeable, error = select.select(socket_connected, [], [])
        for socket in readable:
            if(socket == server):   # New client connected
                new_client, address = server.accept()
                hand = handshake(new_client)
                if hand != 0:
                    print 'Error with handshake:', hand
            else:   # Existing client
                try:
                    data = socket.recv(size)
                    data = data.strip()
                    data = data.split('\n')
                    #print 'Recived:', data
                except:
                    pass
                for message in data:
                    if message != '':
                        # XML parse message
                        try:
                            xmldoc = minidom.parseString(message)
                        except:
                            socket.send('<message><type>error</type><text>Unreconized command</text></message>')
                        request = xmldoc.getElementsByTagName('type')[0].firstChild.data
                        user = xmldoc.getElementsByTagName('user')[0].firstChild.data
                        print 'User:', user, 'Type:', request, 'Time:', datetime.datetime.now()
                        if (request == 'status'):
                            # Call get status from autodoor.py
                            if not test_mode:
                                arduino.write('2')
                            else:
                                print 'TEST: Sent Arduino "2" (Get Status)'
                            sleep(1)
                            if lock_status == 1:
                                os.system("pb -a The door is LOCKED")
                                #socket.send('<message><type>status</type><text>locked</text></message>')
                            else:
                                os.system("pb -a The door is UNLOCKED")
                                #socket.send('<message><type>status</type><text>unlocked</text></message>')
                        elif (request == 'lock'):
                            # Send lock signal to autodoor.py
                            lock()
                            socket.send('<message><type>ack</type><text>locking</text></message>')
                        elif (request == 'unlock'):
                            # Send unlock signal to autodoor.py
                            unlock()
                            socket.send('<message><type>ack</type><text>unlocking</text></message>')
                        elif (request == 'Calibrate'):
                            # Send Calibrate signal to the arduino
                            if not (test_mode or lockdown):
                                arduino.write('3')
                            else:
                                print 'Fake: Sent Arduino "3" (Calibrate)'
                            socket.send('<message><type>ack</type><text>calibrating</text></message>')
                        elif (request == 'status'):
                            # Query the status of the door
                            arduino.write('2')
                            if lock_status == 0:
                                socket.send('<message><type>ack</type><text>UNLOCKED</text></message>')
                            else:
                                socket.send('<message><type>ack</type><text>LOCKED</text></message>')

                        elif (request == 'Clients'):
                            # Query connected Clients
                            #socket.send('<message><type>ack</type><text>' + connected + '</text></message>')
                            names = []
                            for c in connected:
                                names.append(ip2name(c))
                            os.system("pb -a Connected: %s" % names)

                        else:
                            socket.send('<message><type>error</type> <text>Unreconized command</text></message>')
                    else:   # Client left the session
                        socket.close()
                        socket_connected.remove(socket)
                        #print 'Disconnected:', socket

if __name__ == "__main__":
    main()
